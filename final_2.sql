 
/*
6. Создать два индекса для заданных таблиц по заданным полям. Одно задание – один индекс. Название индекса должно начитаться с префикса
”index_”:
6.1. Таблица: Владельцы. Атрибуты: ФИО
6.2. Таблица: Автомобили. Атрибуты: Номер_лицензии, Регистрационный_номер 
*/

create index "index_Владельцы" on "Владельцы" ("Имя", "Фамилия", "Отчество");

select * from pg_indexes
where indexname like 'index_Владельцы';

create index "index_Автомобили" on "Автомобили" ("Номер_лицензии", "Регистрационный_номер");

select * from pg_indexes
where indexname  = 'index_Автомобили';

--------------------------------------------------------------------------------------------------



/*
7. Написать процедуры и функции, согласно условиям . Все процедуры и функции при необходимости должны включать обработчики исключений.
Названия функций: F_<имя>. Формат названий процедур: P_<имя>. Написать анонимные блоки или запросы для проверки работы процедур и
функций.
7.1. Написать функцию, которая для заданной страховой компании возвращает количество автовладельцев имеющих действующие полисы
(id_компании и промежуток времени – аргументы функции). Если промежуток времени не указан, считается количество за всё время.
*/

 
create or replace function F1("_ID_Компании" in integer, _first_date in varchar(10) default null, _second_date in varchar(10) default null)
returns integer as $$
declare
	txt_error text;
	count_policies integer;
	first_date date;
	second_date date;
begin 
	if "_ID_Компании" is null then
		raise exception 'Ошибка: ID_Компании не должен быть null';
	end if;
	
	if _first_date is null then
		select min("Дата_начала") into _first_date from "Страховые_полисы";
		raise notice 'Дата начала не указана. Выбрана следующая дата: %', to_date(_first_date, 'YYYY-MM-DD');
	end if;
	
	if _second_date is null then
		_second_date = to_char(current_date, 'YYYY-MM-DD'); 
		--В подсчёт идут все действующие полиса с момента первого страхования по текущее время 
		raise notice 'Дата конца не указана. Выбрана текущая дата: %', _second_date;
	end if;
	
	first_date = to_date(_first_date, 'YYYY-MM-DD');
	second_date = to_date(_second_date, 'YYYY-MM-DD');
	
	if first_date >= second_date then
		raise exception 'Ошибка: Промежуток времени неверный';
	end if;
	
	select count(*) from "Страховые_компании"
	into count_policies
	join "Страховые_полисы" 
		on  "Страховые_полисы"."ID_Компании" = "_ID_Компании" and "Страховые_полисы"."ID_Компании" = "Страховые_компании"."ID_Компании"
	where ("Дата_начала" >= first_date and "Дата_окончания" <= second_date or ("Дата_начала" >= first_date and  "Дата_окончания" is null));
	--(За заданный промежуток времени включаем бессрочные вставки, т.к. это действующая ставка и может быть также включена в заданную область)
	--p.s. в 7.3 бессрочных вставок не включал по условию
	return count_policies;
exception
	when others then
		get stacked diagnostics txt_error = message_text;
       	raise exception '%', txt_error;
end; $$ language plpgsql


-----------------------------------------------------------------------------------------------------------------

/*
7.2. Написать функцию, которая для каждой страховой компании возвращает среднюю длительность страхового периода в днях. Значение может
рассчитываться за конкретный период и/или для конкретной марки автомобиля. Принадлежность страхового периода указному временному
промежутку определяется по дате начала, бессрочные полисы в расчете не учитываются. Функция имеет три аргумента: id_копании, начало
периода (с точностью до дня), окончание периода (с точность до дня). Только первый аргумент является обязательным. Предусмотреть вариант
вызова функции без необязательных аргументов. 
*/




--"и/или для конкретной марки автомобиля." -> Скорее, предполагалось для конкретной компании.

drop function if exists F2(integer, varchar, varchar);
create or replace function F2("_ID_Компании" in integer, _first_date in varchar(10) default null, _second_date in varchar(10) default null)
returns integer as $$
declare
  txt_error text;
  first_date date;
  second_date date;
  count_policies integer;
begin 
	if "_ID_Компании" is null then
		raise exception 'Ошибка: ID_Компании не должен быть null';
	end if;

	if _first_date is null then
		select min("Дата_начала") into _first_date from "Страховые_полисы";
		raise notice 'Дата начала не указана. Выбрана следующая дата: %', to_date(_first_date, 'YYYY-MM-DD');
		
	end if;
	if _second_date is null then
		select max("Дата_окончания") into _second_date from "Страховые_полисы";
		raise notice 'Дата конца не указана. Выбрана следующая дата: %', to_date(_second_date, 'YYYY-MM-DD');
		--т.к считаем среднюю длительность, то для подсчёта за всё время - находим макс. дату окончания. 
	end if;
	
	first_date = to_date(_first_date, 'YYYY-MM-DD');
	second_date = to_date(_second_date, 'YYYY-MM-DD');
	
	if first_date >= second_date then
		raise exception 'Ошибка: Промежуток времени неверный';
	end if;
	
	select extract(day from avg("Дата_окончания" - "Дата_начала")) into count_policies
	from "Страховые_компании"
	join "Страховые_полисы" 
		on "Страховые_полисы"."ID_Компании" = "Страховые_компании"."ID_Компании"
			and "Страховые_полисы"."ID_Компании" = "_ID_Компании"
	where ("Дата_начала" >= first_date and "Дата_окончания" <= second_date);
	
	if count_policies is null then
		raise notice 'Количество дней равно 0';
		count_policies = 0;
	end if;
	
	return count_policies;
	
exception
  when others then
    get stacked diagnostics txt_error = message_text;
         raise exception '%', txt_error;
end; $$ language plpgsql;


--------------------------------------------------------------------------------------------------------


/*
7.3. Написать процедуру, которая формирует список автомобилистов с истёкшим сроком страхования в заданном округе регистрации (округ
регистрации – аргумент процедуры). Обратите внимание, что на автомобиль может быть оформлено несколько полисов. Формат вывода:
------------------------------------------------------
Список автовладельцев для проверки на <число>:
1. <ФИО автовладельца 1>. Полис <номер полиса> на <марка> рег.номр <регистрационный номер> просрочен на <число> дня.
<и т.д.>….
------------------------------------------------------
*/


create or replace procedure P73("_Округ_регистрации" in varchar)
language plpgsql as $$
declare
	
	curs no scroll cursor for
		select "Имя" || ' ' || "Фамилия" || ' ' || "Отчество" as "ФИО_автовладельца",
			"Номер_полиса",  "Марка", "Автомобили"."Регистрационный_номер", extract(day from current_timestamp - "Дата_окончания") as "Количество_просроченных_дней" from "Владельцы"
		join "Автомобили" on lower("Автомобили"."Округ_регистрации") = lower("_Округ_регистрации")
			and "Автомобили"."Номер_лицензии" = "Владельцы"."Номер_лицензии"
		join "Страховые_полисы" on "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
		where "Дата_окончания" < current_timestamp
		order by "Автомобили"."Регистрационный_номер";
	txt_error text;
	txt_output text;
	num integer;
	last_owner varchar;

begin
	if "_Округ_регистрации" is null then
		raise exception 'Ошибка: Округ регистрации не должен быть null';
	end if;
	
	select 1 into num
	from "Автомобили" where lower("Округ_регистрации") = lower("_Округ_регистрации");
	
	if num is null then
		raise exception 'Ошибка: Округ регистрации "%" не был найден', "_Округ_регистрации";
	end if;
	
	raise notice 'Список автовладельцев. Округ: %', "_Округ_регистрации";
	for it in curs loop
		if last_owner is null or last_owner != it."ФИО_автовладельца" then 
			last_owner = it."ФИО_автовладельца";
			txt_output = num || '. ' || last_owner ||  '. Полис №' || it."Номер_полиса" || ' на ' || it."Марка" 
				|| ' рег. номер №' || it."Регистрационный_номер" || ' просрочен на ' || it."Количество_просроченных_дней" || ' дня(дней).';
			raise notice '%', txt_output;
			num = num + 1;
		else 
			--красота требует жертв 
			txt_output = lpad('', (5 + log(num) + length(it."ФИО_автовладельца"))::int, '_');
			raise notice '%Полис №% на % рег.номер №%. просрочен на % дня(дней).', txt_output, it."Номер_полиса", it."Марка", it."Регистрационный_номер", it."Количество_просроченных_дней";
		end if;
	end loop;
	
	if last_owner is null then
		raise notice 'Просроченных полисов в заданном округе нет!';
	end if;
	
exception
  when others then
    get stacked diagnostics txt_error = message_text;
         raise exception '%', txt_error;
end; $$

;

CALL P73('Центральный');
create or replace procedure P_TEMP(arg integer)
language plpgsql as $$
declare
	num integer;
begin
	select 1 into num
	from "хаха" where "хаха".hheh = arg;
	if num is null then 
		raise notice 'hello world';
	end if;
end; $$
create table "хаха"
(
	hheh integer not null
);
insert into "хаха" (hheh) values (1);
call P_TEMP(1);
select * from "хаха"
insert into "Страховые_полисы" ("Номер_полиса", "ID_Компании",  "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страхования", "Сумма")
values   
(default, 2, 2, '2019-01-15 08:15:30', '2021-12-20', 'ХАЧУМИРИ', 10000)
;



select * from "Страховые_полисы";

select "Имя" || ' ' || "Фамилия" || ' ' || "Отчество" as "ФИО_автовладельца",
			"Номер_полиса",  "Марка", "Автомобили"."Регистрационный_номер", "Округ_регистрации", extract(day from current_timestamp - "Дата_окончания") as end from "Владельцы"
		join "Автомобили" on "Автомобили"."Округ_регистрации" = 'Центральный'
			and "Автомобили"."Номер_лицензии" = "Владельцы"."Номер_лицензии"
		join "Страховые_полисы" on "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
		where "Дата_окончания" < current_timestamp
		order by "Владельцы"."Номер_лицензии";

select * from "Владельцы"
select * from "Автомобили";

select  "Номер_лицензии", "Марка", "Цвет", "Страховые_полисы"."Регистрационный_номер" from "Автомобили"
join "Страховые_полисы" on "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
order by "Номер_лицензии"
;

select * from "Страховые_компании"
;

select * from "Страховые_полисы"
order by "ID_Компании";

----------------------------


/*
7.4. Написать процедуру, которая выполняете копирование всех данных об указанной страховой компании, включая страховые полисы. Аргумент
процедуры - id_компании. Для скопированной записи ставится отметка “копия” в поле название.
*/


create or replace procedure P74("_ID_Компании" in integer)
language plpgsql as $$
declare 
	new_id integer;
	inc_id integer;
	curs no scroll cursor for
		select * from "Страховые_полисы"
		where "ID_Компании" = "_ID_Компании";
    txt_error text;
begin 
	if "_ID_Компании" is null then
		raise exception 'Ошибка: ID_Компании не должен быть null';
	end if;
	
	select 1 from "Страховые_компании" into new_id
	where "Страховые_компании"."ID_Компании" = "_ID_Компании";
	
	if new_id is null then
		raise exception 'Ошибка: ID_компании "№%" не был найден', "_ID_Компании"; 
	end if;
	
	select max("ID_Компании") + 1 into new_id
	from "Страховые_компании";
	
	insert into "Страховые_компании"("ID_Компании", "Название", "Адрес", "Телефон")
	select new_id, 'копия ' || "Название", "Адрес", "Телефон"
	from "Страховые_компании"
	where "Страховые_компании"."ID_Компании" = "_ID_Компании";
	
	select max("Номер_полиса") into inc_id
	from "Страховые_полисы";
	for i in curs loop
		inc_id = inc_id + 1;
		insert into "Страховые_полисы" ("Номер_полиса", "ID_Компании", "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страхования", "Сумма")
		values (inc_id, new_id, i."Регистрационный_номер", i."Дата_начала",i."Тип_страхования", i."Сумма");
	end loop;
	
exception
  when others then
    get stacked diagnostics txt_error = message_text;
         raise exception '%', txt_error;
end; $$

select * from "Страховые_полисы"
order by "ID_Компании";
call P74(1);
select * from "Страховые_компании"


/*
7.5. Написать один или несколько сценариев (анонимных блока) демонстрирующий работу процедур и функций из пп. 1-4.
Требование:
- Включение в запрос (для функций)
- Для каждой процедуры не менее 3-х примеров работы с различными значениями аргументов.
- Комментарии для каждого сценария описывающие суть примера и результат.
*/

--7.1
select * from "Страховые_полисы"
where "ID_Компании" = 2; --Чтобы посмотреть на результат следующих 3 запроса 
 
select  * from F2(2, '2020-01-15') as count_policies;  --количество действующих полисов за период '2020-01-15' по текущее время

select * from F2(2) as count_policies; --количество действующих полисов с момента первой регистрации страховки по текущее время 

select * from F2(2, '2021-01-01', '2024-01-01') as count_policies; --количество действующих полисов с момента регистрации 2021-01-01 по 2024-01-01

--7.2
select * from "Страховые_полисы"
where "ID_Компании" = 5; --Чтобы посмотреть на результат следующих 3 запроса 

select * from F2(5, null,'2024-12-12') as avg_days;

select * from "Страховые_полисы"
where "ID_Компании" = 4;
select * from F2(4) as avg_days;

select * from "Страховые_полисы"
where "ID_Компании" = 2;

select * from F2(2, '2019-01-01', '2021-12-12') as avg_days;
select * from F2(2) as avg_days;

--7.3

call P73('Южный'); --Нет просроченных полисов в заданном округе
call P73('Благородный'); -- Округ регистрации "Благородный" не был найден
call P73('Центральный');
--
--NOTICE:  Список автовладельцев. Округ: Центральный
--NOTICE:  1. Волкова Елизавета Ильинична. Полис №6 на Huyndai рег. номер №6 просрочен на 14 дня(дней).
--NOTICE:  2. Цветущая Роза Васильевна. Полис №13 на Ford рег. номер №11 просрочен на 341 дня(дней).

insert into "Страховые_полисы" ("Номер_полиса", "ID_Компании",  "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страхования", "Сумма")
values   
(default, 2, 11, '2019-01-15 08:15:30', '2021-12-20', 'ЦИСКО', 10000)
;
		
call P73('Центральный');

--NOTICE:  Список автовладельцев. Округ: Центральный
--NOTICE:  1. Золотов Андрей Матвеевич. Полис №14 на Lada рег. номер №2 просрочен на 7 дня(дней).
--NOTICE:  2. Волкова Елизавета Ильинична. Полис №6 на Huyndai рег. номер №6 просрочен на 14 дня(дней).
--NOTICE:  3. Цветущая Роза Васильевна. Полис №13 на Ford рег. номер №11 просрочен на 341 дня(дней).
--NOTICE:  ______________________________Полис №15 на Ford рег.номер №11. просрочен на 7 дня(дней).


insert into "Страховые_полисы" ("Номер_полиса", "ID_Компании",  "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страхования", "Сумма")
values   
(default, 2, , '2019-01-15 08:15:30', '2021-12-20', 'ЦИСКО', 10000)
;

insert into "Автомобили" ("Регистрационный_номер", "Номер_лицензии", "Марка", "Цвет", "Объём_двигателя",
         "Дата_тех_обслуживания", "Округ_регистрации")
values (default, 12, 'Mersedes', 'Черный', 3.2, '2021-12-12 14:14:50', 'Центральный');

select * from "Автомобили";

insert into "Страховые_полисы" ("Номер_полиса", "ID_Компании",  "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страхования", "Сумма")
values   
(default, 2, 14, '2019-01-15 08:15:30', '2021-12-20', 'ЦИСКО', 10000)
;
call P73('Центральный');

--NOTICE:  Список автовладельцев. Округ: Центральный
--NOTICE:  1. Золотов Андрей Матвеевич. Полис №14 на Lada рег. номер №2 просрочен на 7 дня(дней).
--NOTICE:  2. Волкова Елизавета Ильинична. Полис №6 на Huyndai рег. номер №6 просрочен на 14 дня(дней).
--NOTICE:  3. Цветущая Роза Васильевна. Полис №13 на Ford рег. номер №11 просрочен на 341 дня(дней).
--NOTICE:  ______________________________Полис №15 на Ford рег.номер №11. просрочен на 7 дня(дней).
--NOTICE:  4. Смоленов Евгений Борисович. Полис №17 на Mersedes рег. номер №14 просрочен на 7 дня(дней).



--7.4
select * from "Страховые_компании";
select * from "Страховые_полисы"
order by "ID_Компании";

call P74(1); -- копирование компании Макс
call P74(23); -- Ошибка:ID_компании "№23" не был найден
call P74(null); -- ID_Компании не должен быть null





/*8. 
Создать триггеры, включить обработчики исключений. Написать скрипты для проверки. При необходимости снять ограничения (если
ограничение мешает проверить работу триггера).
*/
alter table "Страховые_полисы"
drop constraint "CH_страховые_полисы_время";

/*
8.1. Написать триггер, активизирующийся при изменении содержимого таблицы «Страховые_полисы» и проверяющий, чтобы дата начала была
меньше даты окончания и поле «сумма» заполнялось автоматически в зависимости от типа страхования и объема двигателя, в соответствии с
таблицей (таблицу задать самостоятельно ).
*/


create table "Объём_двигателя_коэффициенты"
(
	"Номер_таблицы_объём" serial not null,
	"Объём" float not null, --указывается максимальный объем (для расчёта коэфф с объёмами 2.5 и 3.0- выбирается 3.0)
	"Коэффициент" float not null,
	constraint "PK_объём_двигателя_коэффициенты" primary key ("Номер_таблицы_объём"),
	constraint "CH_объём_двигателя_коэффициент" check("Коэффициент" >= 1 and "Коэффициент" < 2.0),
  	constraint "CH_объём_двигателя_объём" check("Объём" >= 1.3 and "Объём" < 6.0)
);

create table "Страховые_полисы_коэффициенты"
(
	"Номер_таблицы_полисы_коэффициенты" serial not null, 
	"Название_страховки" varchar not null,
	"Коэффициент" float not null,
	constraint "CH_страховые_полисы_коэффициент" check("Коэффициент" >= 1 and "Коэффициент" < 2.0),
	constraint "PK_страховые_полисы_коэффициенты" primary key("Номер_таблицы_полисы_коэффициенты")
);

insert into "Страховые_полисы_коэффициенты" values
(default, 'ОСАГО', 1.1),
(default, 'Зелёная карта', 1.3),
(default, 'КАСКО', 1.2),
(default, 'ДСАГО', 1);

insert into "Объём_двигателя_коэффициенты"
values 
(default, 2.0, 1.1),
(default, 2.5, 1.2),
(default, 3.0, 1.25),
(default, 3.5, 1.3),
(default, 4.0, 1.45),
(default, 4.5, 1.5),
(default, 5.5, 1.55);

select * from "Страховые_полисы_коэффициенты";
select * from "Объём_двигателя_коэффициенты";

create or replace function TR81_definition()
returns trigger as $$
declare
  txt_error text;
  type_police varchar;
  volume_coeff float;
  police_coeff float;
begin
	 if new."Дата_окончания" is null then
  		raise exception 'Ошибка: Дата окончания не может быть null';
  end if;
   if new."Дата_начала" is null then
  	new."Дата_начала" = current_timestamp;
  	raise notice 'Дата начала - текущее время';
  end if;
  if new."Дата_окончания" < new."Дата_начала" then
    raise exception 'Ошибка: Время начала страховки превышает время окончания';
  end if; 
 
  select "Страховые_полисы_коэффициенты"."Коэффициент" into police_coeff
  from "Страховые_полисы"
  join "Страховые_полисы_коэффициенты" on lower("Страховые_полисы_коэффициенты"."Название_страховки") = lower(new."Тип_страхования");

  if police_coeff is null then
 	raise exception 'Ошибка: Полис % не существует в базе страховок', new."Тип_страхования";
  end if;

  select min("Объём_двигателя_коэффициенты"."Коэффициент") into volume_coeff
  from "Страховые_полисы"
  join "Автомобили" on "Автомобили"."Регистрационный_номер" = new."Регистрационный_номер"
  join "Объём_двигателя_коэффициенты" on "Объём_двигателя_коэффициенты"."Объём" >= ("Автомобили"."Объём_двигателя") and   
 		 "Объём_двигателя_коэффициенты"."Объём" < "Автомобили"."Объём_двигателя" + 0.5; 
		 --Коэффициенты для объёма по умолчанию записаны с шагом 0.5
		 --При добавлении нового объёма с меньшим шагом 0.5 - для этого навсякий случай предназначена агр. функция min, 
		 --которая находит минимальный коэфф
  new."Сумма" = new."Сумма" * volume_coeff * police_coeff; --Т.к. Сумма не null в таблице Страховые_полисы, то по умолчанию имеется уже сумма без учета коэффициентов
  return new;
exception
  when others then
    get stacked diagnostics txt_error = message_text;
         raise exception '%', txt_error;
end; $$ language plpgsql;

drop trigger if exists TR81 on "Страховые_полисы";
create trigger TR81 
before update or insert 
on "Страховые_полисы"
for each row execute function TR81_definition();

insert into "Страховые_полисы" ("Номер_полиса", "ID_Компании",  "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страхования", "Сумма")
values  (default, 2, 2, '2021-12-26', null, 'КАСКО', 10000) --новая Сумма =  13200

select * from "Страховые_полисы"
where "Регистрационный_номер" = 2
order by "Регистрационный_номер"
;

insert into "Страховые_полисы" ("Номер_полиса", "ID_Компании",  "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страхования", "Сумма")
values  (default, 2, 2, '2021-12-26', null, 'ЮНЕСКО', 10000)
--Ошибка Полис ЮНЕСКО не существует в базе страховок
insert into "Страховые_полисы" ("Номер_полиса", "ID_Компании",  "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страхования", "Сумма")
values  (default, 2, 2, '2021-12-26', '2022', 'КАСКО', 10000) --'Ошибка: Дата окончания не может быть null

insert into "Страховые_полисы" ("Номер_полиса", "ID_Компании",  "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страхования", "Сумма")
values  (default, 2, 2, null, '2022-12-12', 'КАСКО', 10000)
--NOTICE:  Дата начала - текущее время
--INSERT 0 1


/*
8.2. Написать триггер, сохраняющий статистику изменений таблицы «Автомобили» в таблице «Авто_Статистика», в которой хранится дата
изменения, тип изменения (insert, update, delete). Триггер также выводит на экран сообщение с указанием количества дней прошедших со дня
последнего изменения. */


drop table if exists "Авто_Статистика";
create table "Авто_Статистика"
(
  "ID_Статистика" serial not null,
  "Регистрационный_номер" integer not null,
  "Дата_изменения" date not null,
  "Тип_изменения" varchar (10) not null,
  constraint "PK_авто_статистика" primary key ("ID_Статистика")
);


create or replace function TR82_definition()
returns trigger as $TR82_definition$
declare
  "Тип_изменения" varchar(10);
  "Последняя_дата_изменения" date;
begin
  if tg_op = 'INSERT' then
  	"Тип_изменения" := 'INSERT';
  end if;
  if tg_op = 'DELETE' then
  	"Тип_изменения" := 'DELETE';
  end if;
  if tg_op = 'UPDATE' then
  	"Тип_изменения" := 'UPDATE';
  end if;

  select max("Дата_изменения") from "Авто_Статистика"
  into "Последняя_дата_изменения";
  
  if "Последняя_дата_изменения" is not null then
  	raise notice 'Количество дней с момента последнего изменения: %', (current_date - "Последняя_дата_изменения");
  else 
  	raise notice 'Изменений ещё не было';
  end if;
  insert into "Авто_Статистика"("ID_Статистика", "Регистрационный_номер", "Дата_изменения", "Тип_изменения")
  values (default, coalesce(new."Регистрационный_номер", old."Регистрационный_номер"), current_date, "Тип_изменения");

  return new;
end;
$TR82_definition$ language plpgsql;

drop trigger if exists TR82  on "Автомобили";
create trigger TR82 
after insert or update or delete on "Автомобили"
for each row
execute function TR82_definition();


insert into "Владельцы" ("Номер_лицензии", "Имя", "Фамилия", "Отчество", "Телефон", "Адрес")
values (default, 'Добрыня', 'Алеша', 'Илья ','+7 982 157-20-51', 'Томская область, г. Томск, ул. Лыткина, дом 12, квартира 413');

insert into "Автомобили" ("Регистрационный_номер", "Номер_лицензии", "Марка", "Цвет", "Объём_двигателя",
         "Дата_тех_обслуживания", "Округ_регистрации")
values (default, 13, 'Mersedes', 'Черный', 3.2, '2021-12-12 14:14:50', 'Центральный'); 
--NOTICE:  Изменений ещё не было
--INSERT 0 1

update "Автомобили"
set "Цвет" = 'Розовый'
where "Номер_лицензии" = 13;

delete from "Автомобили"
where "Номер_лицензии" = 13;

select * from "Авто_Статистика";
select * from "Владельцы";
select * from "Автомобили";




/*8.3. Написать триггер, активизирующийся при вставке в таблицу “Страховые компании ” и проверяющий наличие компании с указанным
наименованием. Если такая компания уже существует, вместо вставки обновляются значения полей адрес и телефон. */

create or replace function TR83_definition()
returns trigger as $$
declare
  txt_error text;
  "Текущее_название_компании" varchar;
begin
  select "Название" into "Текущее_название_компании"
  from "Страховые_компании"
  where lower("Название") = lower(new."Название");
  if "Текущее_название_компании" is not null then
  		update "Страховые_компании"
		set "Адрес" = new."Адрес", "Телефон" = new."Телефон"
		where lower("Название") = lower(new."Название");
		return old;
  else return new;
  end if;	
  
exception
  when others then
    get stacked diagnostics txt_error = message_text;
         raise exception '%', txt_error; 
end; $$ language plpgsql;

drop trigger if exists TR83 on "Страховые_компании";
create trigger TR83
before insert 
on "Страховые_компании"
for each row execute function TR83_definition();

insert into "Страховые_компании"("ID_Компании", "Название", "Адрес", "Телефон")
values (default, 'Бабл', 'Томская область. г. Томск. ул. Нахимова, 14', '-');

select * from "Страховые_компании";

insert into "Страховые_компании"("ID_Компании", "Название", "Адрес", "Телефон")
values (default, 'Бабл', 'Томская область. c. Молчаново', '+7 923 451 43 43');

